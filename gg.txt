    pub fn save(&self, path: &str) -> io::Result<()> {
        let mut writer = BufWriter::new(File::create(path)?);

        write_u32(&mut writer, self.layers.len() as u32)?;
        if !self.layers.is_empty() {
            write_u32(&mut writer, self.layers[0].input_size as u32)?;
        }
        for layer in &self.layers {
            write_u32(&mut writer, layer.hidden_size as u32)?;
        }
        write_u32(&mut writer, self.output_layer.weights.cols() as u32)?;

        for layer in &self.layers {
            write_matrix(&mut writer, &layer.wf)?;
            write_matrix(&mut writer, &layer.wi)?;
            write_matrix(&mut writer, &layer.wc)?;
            write_matrix(&mut writer, &layer.wo)?;

            write_matrix(&mut writer, &layer.b)?;
        }

        write_matrix(&mut writer, &self.output_layer.weights)?;
        write_vec(&mut writer, &self.output_layer.biases)?;

        Ok(())
    }

    pub fn load(path: &str) -> io::Result<Self> {
        let mut reader = BufReader::new(File::open(path)?);

        let num_layers = read_u32(&mut reader)? as usize;
        let input_size = if num_layers > 0 {
            (read_u32(&mut reader)? as usize, 0)
        } else {
            (0, 0)
        };
        let mut hidden_sizes = Vec::with_capacity(num_layers);
        for _ in 0..num_layers {
            hidden_sizes.push((read_u32(&mut reader)? as usize, read_u32(&mut reader)? as usize));
        }
        let output_size = read_u32(&mut reader)? as usize;

        let mut layout = vec![input_size];
        layout.extend(hidden_sizes.iter().cloned());

        let mut lstm = Self::new(&layout, output_size);

        for layer in lstm.layers.iter_mut() {
            let rows = layer.input_size + layer.hidden_size;
            layer.wf = read_matrix(&mut reader, rows, layer.hidden_size)?;
            layer.wi = read_matrix(&mut reader, rows, layer.hidden_size)?;
            layer.wc = read_matrix(&mut reader, rows, layer.hidden_size)?;
            layer.wo = read_matrix(&mut reader, rows, layer.hidden_size)?;
            layer.b = read_matrix(&mut reader, 4, layer.hidden_size)?;
        }

        let output_input_size = if let Some(last_hidden) = layout.last() {
            *last_hidden
        } else {
            (0, 0)
        };
        lstm.output_layer.weights = read_matrix(&mut reader, output_input_size.0, output_size)?;
        lstm.output_layer.biases = read_vec(&mut reader, output_size)?;

        Ok(lstm)
    }

    fn write_u32<W: Write>(writer: &mut W, val: u32) -> io::Result<()> {
    writer.write_all(&val.to_le_bytes())
}

fn read_u32<R: Read>(reader: &mut R) -> io::Result<u32> {
    let mut buf = [0u8; 4];
    reader.read_exact(&mut buf)?;
    Ok(u32::from_le_bytes(buf))
}

fn write_matrix<W: Write>(writer: &mut W, matrix: &Matrix) -> io::Result<()> {
    for i in matrix.as_slice() {
        writer.write_all(&i.to_le_bytes())?;
    }
    Ok(())
}

fn read_matrix<R: Read>(reader: &mut R, rows: usize, cols: usize) -> io::Result<Matrix> {
    let mut matrix = Matrix::uninit(rows, cols);
    let mut buf = [0u8; 4];
    for row in 0..rows {
        for col in 0..cols {
            reader.read_exact(&mut buf)?;
            matrix[row][col] = f32::from_le_bytes(buf);
        }
    }
    Ok(matrix)
}

fn write_vec<W: Write>(writer: &mut W, vec: &[f32]) -> io::Result<()> {
    for &val in vec {
        writer.write_all(&val.to_le_bytes())?;
    }
    Ok(())
}

fn read_vec<R: Read>(reader: &mut R, len: usize) -> io::Result<Box<[f32]>> {
    let mut vec = vec![0.0; len].into_boxed_slice();
    let mut buf = [0u8; 4];
    for i in 0..vec.len() {
        reader.read_exact(&mut buf)?;
        vec[i] = f32::from_le_bytes(buf);
    }
    Ok(vec)
}
